# -*- coding: utf-8 -*-
"""
/***************************************************************************
 EmergencyDispatcher
                                 A QGIS plugin
 Generate routes by using online services (Google Directions, Here, MapBox, YourNavigation, OSRM etc.)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-10-01
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Mehmet Selim BILGIN
        email                : mselimbilgin@yahoo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QPoint, QVariant
from PyQt5.QtGui import QIcon, QColor
from PyQt5.QtWidgets import QAction, QMessageBox
from qgis.PyQt.QtCore import Qt

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .EmergencyDispatcher_dialog import * 
import os.path
from urllib.request import urlopen

from .routeprovider import RouteProvider
from .db import *
from .util import *
from qgis.gui import *
from qgis.core import *

import platform
from .config import *
from .apikey import *
from qgis.PyQt.QtWidgets import QTableWidgetItem,QPushButton,QFileDialog
import pygame
import matplotlib.pyplot as plt
from collections import Counter,defaultdict
from matplotlib.ticker import MaxNLocator



class CustomMapTool(QgsMapToolIdentifyFeature):
    def __init__(self, canvas, layersPoints):
        QgsMapToolIdentifyFeature.__init__(self, canvas)
        self.canvas = canvas
        self.layersPoints = layersPoints  # Lista de layers de points

    def canvasReleaseEvent(self, event):
        # Identificar características en todas las layers de points
        attribute_text = ""
        for layer_points in self.layersPoints:
            results = self.identify(event.x(), event.y(), [layer_points], QgsMapToolIdentify.TopDownStopAtFirst)
            if results:
                feature = results[0].mFeature
                fields = feature.fields()
                
                for field, attribute in zip(fields, feature.attributes()):
                    if field.name() not in ['column_x', 'column_y']:
                        attribute_text += f"{field.name()} {attribute}\n"
        
        if attribute_text:  # Solo mostrar el diálogo si hay atributos encontrados
            self.showAttributeDialog(attribute_text)

    def showAttributeDialog(self, attribute_text):
        dialog = QMessageBox()
        dialog.setWindowTitle("Datos de la salida")
        dialog.setText(attribute_text)
        dialog.exec()
        
class EmergencyDispatcher:
    

    def __init__(self, iface):
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'EmergencyDispatcher_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Emergency Dispatcher')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'Emergency Dispatcher')
        self.toolbar.setObjectName(u'Emergency Dispatcher')
        self.dlgBack = None
        self.listPointsExclution = []
        self.typeAutomovil = None
        self.pathLoadTemplate = None
        
        #variable necesaria para saber que type de emergency es
        self.typeEmergency = 0
        self.address = ""
        self.phone =""
        self.applicant = ""
        self.description = ""
        self.layerStartPoint = None
        self.layerPumps = []

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('EmergencyDispatcher', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/OnlineRoutingMapper/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Emergency Dispatcher'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    def clickHandler(self, pointXY):
        if self.no == 0:
            startPointXY = QgsPointXY(pointXY)
            # self.startRubberBand.removeLastPoint()
            # self.startRubberBand.removeLastPoint()
            self.startRubberBand.addPoint(startPointXY)
            self.dlg.startTxt.setText(str(pointXY.x()) + ',' + str(pointXY.y()))
        else:
            stopPointXY = QgsPointXY(pointXY)
            # self.stopRubberBand.removeLastPoint()
            # self.stopRubberBand.removeLastPoint()
            self.stopRubberBand.addPoint(stopPointXY)
            self.dlg.stopTxt.setText(str(pointXY.x()) + ',' + str(pointXY.y()))
        
         # Ocultar la ventana emergente temporalmente
        self.dlg.hide()

        # Liberar la herramienta de mapa para que se pueda hacer clic nuevamente
        self.canvas.unsetMapTool(self.clickTool)

        # Volver a mostrar la ventana emergente
        self.dlg.show()
        
        # free them
        self.clickTool.canvasClicked.disconnect(self.clickHandler)

    def toolActivator(self, no):
        self.no = no
        self.dlg.showMinimized()
        self.dlgBack.showMinimized()
        self.clickTool.canvasClicked.connect(self.clickHandler)
        self.canvas.setMapTool(self.clickTool)  # clickTool is activated

    def clickHandlerStart(self, pointXY):
        point = QgsPointXY(pointXY)
        self.address = getAddress(point.x(),point.y())
        self.stopRubberBand.addPoint(point)
        self.dlg.hide()

        # Liberar la herramienta de mapa para que se pueda hacer clic nuevamente
        self.canvas.unsetMapTool(self.clickTool)
        # Volver a mostrar la ventana emergente
        self.dlg.show()
        self.dlg.form_direccion.setText(self.address)
        # self.clickTool.canvasClicked.disconnect(self.clickHandler)

    def toolActivatorStartPoints(self):
        self.dlg.showMinimized()
        self.dlgBack.showMinimized()
        self.clickTool.canvasClicked.connect(self.clickHandlerStart)
        self.canvas.setMapTool(self.clickTool)  # clickTool is activated
        

    def clickHandlerPump(self, pointXY):
        pointXY = QgsPointXY(pointXY)
        layer = self.addPointWithcon(pointXY, PATH_IMAGEN_BOMBAS_ICON_SVG, "Bomba")
        if (layer not in self.layerPumps):
            self.layerPumps.append(layer)

        self.dlg.pumpTxt.setText(str(pointXY.x()) + ',' + str(pointXY.y()))
        self.dlg.hide()
        self.canvas.unsetMapTool(self.clickTool)
        self.dlg.show()
        
    def toolActivatorPump(self):
        self.dlg.showMinimized()
        self.dlgBack.showMinimized()
        self.clickTool.canvasClicked.connect(self.clickHandlerPump)
        self.canvas.setMapTool(self.clickTool)  # clickTool is activatedr)
        


    def crsTransform(self, pointXY):
        sourceCRS = self.canvas.mapSettings().destinationCrs()  # getting the project CRS
        destinationCRS = QgsCoordinateReferenceSystem.fromEpsgId(4326)  # google uses this CRS
        transformer = QgsCoordinateTransform(sourceCRS, destinationCRS,
                                             QgsProject.instance())  # defining a CRS transformer
        outputQgsPoint = transformer.transform(pointXY, QgsCoordinateTransform.ForwardTransform)

        return str(outputQgsPoint.y()) + ',' + str(outputQgsPoint.x())
    
    def crsTransformPedido(self, pointXY):
        sourceCRS = self.canvas.mapSettings().destinationCrs()  # getting the project CRS
        destinationCRS = QgsCoordinateReferenceSystem.fromEpsgId(4326)  # google uses this CRS
        transformer = QgsCoordinateTransform(sourceCRS, destinationCRS,
                                             QgsProject.instance())  # defining a CRS transformer
        outputQgsPoint = transformer.transform(pointXY, QgsCoordinateTransform.ForwardTransform)

        return str(outputQgsPoint.x()) + ',' + str(outputQgsPoint.y())

    def checkNetConnection(self):
        try:
            urlopen('http://www.google.com', timeout=10)
            return True
        except Exception as err:
            pass
        return False

    def routeMaker(self, wktLineString):
        feature = QgsFeature()
        feature.setGeometry(QgsGeometry.fromWkt(wktLineString))
        vectorLayer = QgsVectorLayer('LineString?crs=epsg:4326', 'Routing Result', 'memory')
        layerProvider = vectorLayer.dataProvider()
        vectorLayer.startEditing()
        layerProvider.addFeatures([feature])
        vectorLayer.commitChanges()
        vectorLayer.updateExtents()
        vectorLayer.loadNamedStyle(self.plugin_dir + os.sep + 'EmergencyDispatcher.qml')
        QgsProject.instance().addMapLayer(vectorLayer)
        destinationCRS = self.canvas.mapSettings().destinationCrs()  # getting the project CRS
        sourceCRS = QgsCoordinateReferenceSystem.fromEpsgId(4326)
        transformer = QgsCoordinateTransform(sourceCRS, destinationCRS, QgsProject.instance())
        extentForZoom = transformer.transform(vectorLayer.extent(), QgsCoordinateTransform.ForwardTransform)
        self.canvas.setExtent(extentForZoom)
        self.canvas.zoomScale(self.canvas.scale() * 1.03)  # zoom out a little bit.
        QMessageBox.information(self.dlg, 'Informacion', 'Ruta calculada con éxito.')

    def runAnalysis(self):
        # if len(self.dlg.startTxt.text()) > 0 and len(self.dlg.stopTxt.text()) > 0:
        if self.startPointXY is not None and self.stopPointXY is not None:
            jurisdiction = QgsProject.instance().mapLayersByName('Jurisdicción')
            if len(jurisdiction) > 0:
                polygon = jurisdiction[0]
                if not polygon.getFeature(1).geometry().contains(self.stopPointXY):
                    QMessageBox.warning(self.dlg, 'Calculate routes pumps',"El point esta fuera de la juridiccion")
            if self.checkNetConnection():  
                startPoint = self.crsTransform(self.startPointXY)
                stopPoint = self.crsTransform(self.stopPointXY)   
                # index = self.dlg.serviceCombo.currentIndex()
                try:
                    service = self.services[list(self.services)[TYPE_SERVICIO_HERE_V8]]
                    self.loadListPoints()
                    wkt, url = service(startPoint, stopPoint, self.listPointsExclution, self.typeAutomovil)
                    wkt2, url2 = service(stopPoint, startPoint, self.listPointsExclution, self.typeAutomovil)
                    report(url, url2)
                    self.persistOrder(url)
                    if self.typeEmergency in (1,2,3,4):
                        self.calculateRoutesPumps(stopPoint)

                    self.routeMaker(wkt)
                    self.dlg.showMinimized()
                    self.listPointsExclution=[]
                except Exception as err:
                    print(err)
                    QgsMessageLog.logMessage(str(err))
                    QMessageBox.warning(self.dlg, 'Analysis Error',
                                        "Verificar que el sistema de coordenadas sea EPSG:4326. \nCannot calculate the route between the start and stop locations that you entered. Please use other Service APIs.")
            else:
                QMessageBox.warning(self.dlg, 'Network Error!', 'There is no internet connection.')
        else:
            QMessageBox.information(self.dlg, 'Warning', 'Please choose Start Location and Stop Location.')
    
    
    def persistOrder(self, url):
        try:
            response = urlopen(url).read().decode("utf-8")
            diccionario = json.loads(response)
            estimatedTime = round(int(diccionario['routes'][0]['sections'][0]['summary']['duration'])/60)
            description = self.description
            direccion = self.address
            applicant = self.applicant
            phone = self.phone
            categoria={
                '1':'INCENDIO FORESTAL',
                '2':'INCENDIO RURAL',
                '3':'INCENDIO VEHICULAR',
                '4':'INCENDIO ESTRUCTURAL',
                '5':'ACCIDENTE',
                '6':'MATERIAL PELIGRO',
                '7':'VARIOS',
                '8':'RESCATE DE ALTURA'
            }.get(str(self.typeEmergency),'Desconocido')
            valores = "'{}', '{}', '{}', '{}', '{}', '{}', '{}', '{}', '{}','{}', now()".format(direccion, applicant, phone, "Pedro", self.crsTransformPedido(self.startPointXY),self.crsTransformPedido(self.stopPointXY), description, estimatedTime, categoria, estimatedTime)
            insert('order', 'direccion, applicant, phone, operador, startpoint, stoppoint, description, estimatedTime,type, estimatedActual, fecha', valores)
                
        except Exception as e:
            QgsMessageLog.logMessage(str(e))
            QMessageBox.warning(self.dlg, 'persistOrder', "Error al intentar guardar el order")
            
    def calculateRoutesPumps(self, startPoint):
        try:
            pumps = select('pump')
            if (len(pumps)!=0):
                service = self.services[list(self.services)[TYPE_SERVICIO_HERE_V8]]
                distances = []
                for tuple in pumps:
                    if (tuple[4] == 'A'):
                        wkt, url = service(startPoint, self.crsTransform(QgsPointXY(float(tuple[1]), float(tuple[2]))))
                        response = urlopen(url).read().decode("utf-8")
                        diccionario = json.loads(response)
                        d = int(diccionario['routes'][0]['sections'][0]['summary']['length'])
                        distances.append([d,tuple[3]])

                list_distances = sorted(distances, key=lambda x: x[0])
                f = open (PATH_REPORTE,'a')
                f.write('\nLas Bombas de agua más cercanas de menor a mayor:\n')
                for tuple in list_distances:
                    f.write(str(tuple[1])+ ", distancia :"+ str(tuple[0])+'\n')
                f.close()
        except Exception as err:
            QgsMessageLog.logMessage(str(err))
            QMessageBox.warning(self.dlg, 'Calculate routes pumps',"Hubo un error al calcular las pumps mas cercanas")

    def calculatePoints(self):
        try:
            address = self.dlg.form_direccion.text()+ " " + CIUDAD + " " + PROVINCIA
            x, y = getCoordinate(address)
            self.stopPointXY = QgsPointXY(x,y)
            self.address = address
        except Exception as e:
            QgsMessageLog.logMessage(str(e))
            QMessageBox.warning(self.dlg, 'calculatePoints', "Error al obtener coordenada o direccion")
    
    def callSound(self, path_sound, emergency):
        self.typeEmergency = emergency
        pygame.init()

        # Configura el sistema de sonido
        pygame.mixer.init()

        # Carga el archivo de sonido
        sonido = pygame.mixer.Sound(path_sound)

        # Reproduce el sonido
        sonido.play()


    def changeScreenPlaceAnOrder(self):
        self.dlg = EmergencyDispatcherDialogPlaceAnOrder()
        self.dlg.form_description.setFocus()        
        self.dlg.setFixedSize(self.dlg.size())
        self.dlg.show()
        self.dlg.comboBox_2.addItems(OPERATORS)
        options = [TRUCK, LIGHT_TRUCK, HEAVY_TRUCK]
        self.dlg.comboBox.addItems(options)
        self.dlg.buttonIncendioForestal.clicked.connect(lambda: self.callSound(SONIDO_ALARMA_INCENDIO_FORESTAL, 1))
        self.dlg.buttonIncendioRural.clicked.connect(lambda: self.callSound(SONIDO_ALARMA_INCENDIO_RURAL, 2))
        self.dlg.buttonIncendioVehicular.clicked.connect(lambda: self.callSound(SONIDO_ALARMA_INCENDIO_VEHICULAR, 3))
        self.dlg.buttonIncendioEstructura.clicked.connect(lambda: self.callSound(SONIDO_ALARMA_RESCATE_ESTRUCTURA, 4))
        self.dlg.buttonAccidenteVehicular.clicked.connect(lambda: self.callSound(SONIDO_ALARMA_ACCIDENTE_VEHICULAR, 5))
        self.dlg.buttonAccidenteMatPel.clicked.connect(lambda: self.callSound(SONIDO_ALARMA_ACCIDENTE_MAT_PEL, 6))
        self.dlg.buttonEmergVarias.clicked.connect(lambda: self.callSound(SONIDO_ALARMA_EMERGENCIAS_VARIAS, 7))
        self.dlg.buttonRescateDeAltura.clicked.connect(lambda: self.callSound(SONIDO_ALARMA_RESCATE_DE_ALTURA, 8))
        self.canvas = self.iface.mapCanvas()
        self.clickTool = QgsMapToolEmitPoint(self.canvas)
        self.dlg.buscarPunto.clicked.connect(lambda: self.toolActivatorStartPoints())
        self.dlg.back_to.clicked.connect(lambda: self.backScreen())
        self.dlg.acceptOrder.clicked.connect(lambda: self.accept())


    def accept(self):
        address = self.dlg.form_direccion.text()
        description=self.dlg.form_description.text()
        applicant=self.dlg.form_applicant.text()
        phone=self.dlg.form_phone.text()
        if ((address and address.strip()) or (self.stopPointXY is not None)):
            self.typeAutomovil = self.dlg.comboBox.currentText()
            self.savePoints()
            self.dlg = self.dlgBack
            self.dlg.show()
            writeReport(description, address, applicant, phone)
            self.runAnalysis()
        else : QMessageBox.warning(self.dlg, 'Aviso', "Ingresa al menos una direccion")
        
    # def add_table_item(self, row, column, text):
    #     # Método para agregar un elemento a la tabla
    #     item = QTableWidgetItem(text)
    #     self.dlg.tableWidget.setItem(row, column, item)
    
    def deleteAllPoints(self):
        # Itera sobre todos los points y los elimina uno por uno
        while self.stopRubberBand.numberOfVertices() > 0:
            self.stopRubberBand.removeLastPoint()
        
        while self.startRubberBand.numberOfVertices() > 0:
            self.startRubberBand.removeLastPoint()

        self.deleteLayerPumps()
        self.vectorRubberBand.reset()
    
    def deleteLayerPumps(self):
        if (len(self.layerPumps)>0):
            allLayers = QgsProject.instance().mapLayers().values()
            for layer in self.layerPumps:
                # if layer in allLayers:
                QgsProject.instance().removeMapLayer(layer)
                self.layerPumps.remove(layer)


    def removePump(self, id):
        # Borrar en la tabla interface
        i=0
        while i < self.dlg.tableWidget.rowCount():
            if int(self.dlg.tableWidget.item(i,0).text()) == id:
                self.dlg.tableWidget.removeRow(i)
            i += 1

        # Borrar en la BD
        delete('pump', id)
        self.addUpdateInitialPoints()

    def updatePump(self, id):
        try:
            found = False
            for i in range(self.dlg.tableWidget.rowCount()):
                if int(self.dlg.tableWidget.item(i, 0).text()) == id:
                    found = True
                    break

            i -= 1
            if found:
                description = self.dlg.tableWidget.item(i,1).text()
                state = self.dlg.tableWidget.item(i,2).text()
                seters = " description = '{}', estado = '{}'".format(description, state)
                update('pump', seters, id)
                QMessageBox.information(self.dlg, 'actualizar_pump', "Actualizacion exitosa")
        except Exception as e:
            QgsMessageLog.logMessage(str(e))
            QMessageBox.warning(self.dlg, 'updatePump', "No se puede modificar el valor")

    def addPump(self, id, description, state):
        rowPosition = self.dlg.tableWidget.rowCount()
        self.dlg.tableWidget.insertRow(rowPosition)
        id_row = QTableWidgetItem(str(id))
        id_row.setTextAlignment(Qt.AlignCenter)
        self.dlg.tableWidget.setItem(rowPosition, 0, id_row)
        descriptionRow =  QTableWidgetItem(description)
        descriptionRow.setTextAlignment(Qt.AlignCenter)
        self.dlg.tableWidget.setItem(rowPosition, 1, descriptionRow)
        stateRow =  QTableWidgetItem(state)
        stateRow.setTextAlignment(Qt.AlignCenter)
        self.dlg.tableWidget.setItem(rowPosition, 2, stateRow)
        deleteButton = QPushButton("X")
        deleteButton.clicked.connect(lambda: self.removePump(id))
        self.dlg.tableWidget.setCellWidget(rowPosition, 3, deleteButton)
        updatePump = QPushButton("Actualizar")
        updatePump.clicked.connect(lambda: self.updatePump(id))
        self.dlg.tableWidget.setCellWidget(rowPosition, 4, updatePump)

    def changeScreenModifyPump(self):
        self.dlg = EmergencyDispatcherDialogModifyPump()
        self.dlg.setFixedSize(self.dlg.size())
        self.dlg.show()
        self.dlg.tableWidget.setColumnCount(5)
        self.dlg.tableWidget.setHorizontalHeaderLabels(["ID", "Descripción", "Estado", "Borrar", "Modificar"])
        
        records = select('pump')
        for tuple in records:
            self.addPump(tuple[0], tuple[3], tuple[4])
        
        self.canvas = self.iface.mapCanvas()
        self.clickTool = QgsMapToolEmitPoint(self.canvas)
        self.dlg.startBtn.clicked.connect(lambda: self.toolActivatorPump())
        self.dlg.back_to.clicked.connect(lambda: self.backScreen())
        self.dlg.aceptar.clicked.connect(lambda: self.savePump())
        self.dlg.closeEvent = self.closeUpdate
        
    def savePump(self):
        if len(self.dlg.pumpTxt.text()) > 0:
            if platform.system() == 'Windows':
                point = self.dlg.pumpTxt.text()
            else:
                pointsStart = self.dlg.pumpTxt.text().split(',')
                point = pointsStart[1]+','+pointsStart[0]
                
            #Inserta los points en la BD 
            startPoint = point.split(',')
            valores = "{}, {}, '{}'".format(startPoint[1], startPoint[0], self.dlg.descriptionTxt.text())
            insert('pump', 'startPoint, stopPoint, description', valores)
        self.dlg = self.dlgBack
        if self.dlg.close():
            self.addUpdateInitialPoints()  
            self.dlg.showNormal()
            


    #tuple esta de mas?
    def remove_points(self, id):
        # Borrar en la tabla interface
        i=0
        while i < self.dlg.tableWidget.rowCount():
            if int(self.dlg.tableWidget.item(i,0).text()) == id:
                self.dlg.tableWidget.removeRow(i)
            i += 1

        # Borrar en la BD
        delete('points', id)
        delete('points', id-1)
        self.addUpdateInitialPoints()

    def addPoint(self, id, description):
        rowPosition = self.dlg.tableWidget.rowCount()
        self.dlg.tableWidget.insertRow(rowPosition)
        self.dlg.tableWidget.setItem(rowPosition, 0, QTableWidgetItem(str(id)))
        self.dlg.tableWidget.setItem(rowPosition, 1, QTableWidgetItem(description))
        deleteButton = QPushButton("Eliminar")
        deleteButton.clicked.connect(lambda: self.remove_points(id))
        self.dlg.tableWidget.setCellWidget(rowPosition, 2, deleteButton)

    def changeScreenModifyMap(self):
        self.dlg = EmergencyDispatcherDialogModifyMap()
        self.dlg.setFixedSize(self.dlg.size())
        self.dlg.show()
        self.dlg.tableWidget.setColumnCount(3)
        self.dlg.tableWidget.setHorizontalHeaderLabels(["ID", "Descripcion", "Acción"])
        records = select('points')
        
        for i, tuple in enumerate(records, start=1):
            if i % 2 == 0:
                self.addPoint(tuple[0], tuple[3])
    

        self.canvas = self.iface.mapCanvas()
        self.clickTool = QgsMapToolEmitPoint(self.canvas)
        self.dlg.startBtn.clicked.connect(lambda: self.toolActivator(0))
        self.dlg.stopBtn.clicked.connect(lambda: self.toolActivator(1))
        self.dlg.back_to.clicked.connect(lambda: self.backScreen())
        self.dlg.aceptar.clicked.connect(lambda: self.savePointsExclution())
        self.dlg.closeEvent = self.closeUpdate

    def createLayerPoints(self, records):
        # Crea una nueva layer de points en memoria
        types = [TYPE1, TYPE2, TYPE3, TYPE4, TYPE5, TYPE6, TYPE7, TYPE8]
        layersPoints = []

        for type in types:
            layer = QgsVectorLayer("Point?crs=EPSG:4326", type, "memory")
            layersPoints.append(layer)

        # Define los fields para la layer de points
        fields = QgsFields()
        fields.append(QgsField("Numero :", QVariant.String))
        fields.append(QgsField("column_x", QVariant.Double))
        fields.append(QgsField("column_y", QVariant.Double))
        fields.append(QgsField("Descripción :", QVariant.String))
        fields.append(QgsField("Dirección :", QVariant.String))
        fields.append(QgsField("Solicitante :", QVariant.String))
        fields.append(QgsField("Tipo :", QVariant.String))
        fields.append(QgsField("Fecha :", QVariant.String))
        fields.append(QgsField("Tiempo Estimado :", QVariant.String))
        fields.append(QgsField("Tiempo Real :", QVariant.String))
        fields.append(QgsField(" ", QVariant.String))

        # Asigna los fields a cada layer
        for layer in layersPoints:
            layer.dataProvider().addAttributes(fields)
            layer.updateFields()

        for tuple in records:
            if tuple[6]!=' ':
                x, y = tuple[6].split(',')
                point = QgsPointXY(float(x), float(y))
                point_geom = QgsGeometry.fromPointXY(point)
                # Crea una nueva característica y agrega la geometría y los atributos
                feature = QgsFeature()
                feature.setGeometry(point_geom)
                feature.setAttributes([tuple[0], x, y, tuple[7], tuple[1],tuple[2],tuple[10], str(tuple[12]), tuple[8], tuple[11], " "])
                # Crear un diccionario para mapear types a índices de layers
                type_a_layer = {
                    TYPE1: layersPoints[0],
                    TYPE2: layersPoints[1],
                    TYPE3: layersPoints[2],
                    TYPE4: layersPoints[3],
                    TYPE5: layersPoints[4],
                    TYPE6: layersPoints[5],
                    TYPE7: layersPoints[6],
                    TYPE8: layersPoints[7]
                }

                # Asignar la característica a la layer correspondiente
                if tuple[10] in type_a_layer:
                    type_a_layer[tuple[10]].dataProvider().addFeature(feature)

        for layer in layersPoints:
            # Agrega la layer al proyecto de QGIS
            QgsProject.instance().addMapLayer(layer)
            # Refresca la interfaz de QGIS
            self.iface.layerTreeView().refreshLayerSymbology(layer.id())
            self.canvas = self.iface.mapCanvas()
        self.clickTool = CustomMapTool(self.canvas,layersPoints)
        self.canvas.setMapTool(self.clickTool)

    def changeScreenStatistics(self):
        self.dlg = EmergencyDispatcherDialogStatistics()
        self.deleteAllPoints()
        self.dlg.setFixedSize(self.dlg.size())
        self.dlg.show()
        self.dlg.button_filter.clicked.connect(lambda: (self.filterEmergencies(FILTRAR_EMERGENCIA)))
        self.dlg.button_graphics_bar.clicked.connect(lambda: (self.filterEmergencies(GRAFICOS_BARRA)))
        self.dlg.button_graphics_line.clicked.connect(lambda: (self.filterEmergencies(GRAFICOS_LINEA)))
        self.dlg.combo_type.addItems(TYPES_EMERGENCIA)
        self.dlg.closeEvent = self.closeOrder
        self.dlg.back_to_statistic.clicked.connect(lambda: self.backScreenStatistic())
    
    def filterEmergencies(self, graphic):
        filtro = {}
        type_emergency = self.dlg.combo_type.currentText()
        if (self.dlg.checkBox_fecha.isChecked()):
            fecha_desde = datetime.strptime(self.dlg.form_fecha_desde.text().strip(), "%d/%m/%y")
            fecha_hasta = datetime.strptime(self.dlg.form_fecha_hasta.text().strip(), "%d/%m/%y")
            filtro['fecha_desde'] = fecha_desde.strftime("%Y-%m-%d 00:00:00")
            filtro['fecha_hasta'] = fecha_hasta.strftime("%Y-%m-%d 23:59:59")

        if (type_emergency != 'Todos'):
            filtro['type_emergency'] = getIdTypeEmergency(type_emergency)
        
        if (self.dlg.checkBox_hora.isChecked()):
            filtro['hours'] = self.dlg.form_hora.text().split(':')[0]
        
        # Ejecuta la consulta SQL y crea los points
        records = select("orders", None, None, filtro)
        if graphic == FILTRAR_EMERGENCIA:
            if (len(records)):
                self.createLayerPoints(records)
                self.dlgBack.showMinimized()
                self.dlg.showMinimized()
            else:
                QMessageBox.information(self.dlg, 'filterEmergencies', "No se encontraron emergencys")
        if graphic == GRAFICOS_BARRA:
            self.graphicsBar(records)
        if graphic == GRAFICOS_LINEA:
            self.graphicsLine(records)


    def graphicsBar(self, records):
        types = [registro[10] for registro in records]
        conteo_types = Counter(types)
        categories = list(conteo_types.keys())
        values = [int(valor) for valor in conteo_types.values()]
        fig, ax = plt.subplots()
        ax.bar(categories,values)

        ax.yaxis.set_major_locator(MaxNLocator(integer=True))
        plt.xlabel('Tipo Emergencia')
        plt.ylabel('Cantidad')
        plt.title('Cantidad de salidas por type')
        plt.show()


    def graphicsLine(self, records):
        # Procesar los datos para la visualización
        data_by_type = defaultdict(lambda: defaultdict(int))

        # Ordenar y acumular los datos por type y fecha
        for registro in records:
            type = registro[10]  # Acceder al campo 'type'
            fecha = str(registro[12]).split(' ')[0]  # Acceder al campo 'fecha'
            cantidad = 1  # Supongamos que cada registro cuenta como 1 emergency
            data_by_type[type][fecha] += cantidad

        # Organizar y ordenar las fechas únicas
        fechas = sorted(set(fecha for type_data in data_by_type.values() for fecha in type_data.keys()))

        # Crear el gráfico
        fig, ax = plt.subplots()

        # Graficar cada type de emergency como una línea separada
        for type, data in data_by_type.items():
            cantidades_por_type = []
            valor_anterior = 0
            
            for fecha in fechas:
                if fecha in data:
                    valor_anterior = data[fecha]
                cantidades_por_type.append(valor_anterior)
            
            ax.plot(fechas, cantidades_por_type, marker='o', linestyle='-', label=type)

        # Configurar etiquetas y leyenda
        ax.yaxis.set_major_locator(MaxNLocator(integer=True))
        ax.set_xlabel('Fecha')
        ax.set_ylabel('Cantidad de emergencys')
        ax.set_title('Cantidad de emergencys por type a lo largo del tiempo')
        ax.legend()

        # Configurar el eje x para mostrar solo valores enteros
        ax.set_xticks(range(len(fechas)))
        ax.set_xticklabels(fechas, rotation=45)

        # Mostrar el gráfico
        plt.tight_layout()
        plt.show()
            
    def backScreenStatistic(self):
        self.closeOrder(None)
        self.dlg.hide()
        self.dlg = self.dlgBack
         
    def updateOrder(self, id):
        try:
            found = False
            for i in range(self.dlg.tableWidget.rowCount()):
                if int(self.dlg.tableWidget.item(i, 0).text()) == id:
                    found = True
                    break

            i -= 1
            if found:
                # Actualizar en la BD
                address = self.dlg.tableWidget.item(i,1).text()
                applicant = self.dlg.tableWidget.item(i,2).text()
                phone = self.dlg.tableWidget.item(i,3).text()
                operator = self.dlg.tableWidget.item(i,4).text()
                startPoint = self.dlg.tableWidget.item(i,5).text()
                stopPoint = self.dlg.tableWidget.item(i,6).text()
                description = self.dlg.tableWidget.item(i,7).text()
                estimatedTime = self.dlg.tableWidget.item(i,8).text()
                estimatedActual = self.dlg.tableWidget.item(i,9).text()
                type = self.dlg.tableWidget.item(i,10).text()
                fecha = self.dlg.tableWidget.item(i,11).text()

                seters = "address = '{}', applicant = '{}', phone = '{}', operator = '{}', startPoint = '{}', stopPoint = '{}', description = '{}', estimatedTime = '{}', estimatedActual = '{}', type = '{}'".format(address, applicant, phone, operator, startPoint, stopPoint ,description,estimatedTime, estimatedActual, type)
            
                update('orders', seters, id)
        except Exception as e:
            QgsMessageLog.logMessage(str(e))
            QMessageBox.warning(self.dlg, 'updateOrder', "No se puede modificar el valor por exceder de caracteres o type incorrecto")

    def addOrder(self, id, direccion, applicant, phone, operador, coordenada_partida, coordenada_lugar, description, estimatedTime, estimatedActual, type, fecha):
        rowPosition = self.dlg.tableWidget.rowCount()
        self.dlg.tableWidget.insertRow(rowPosition)
        item = QTableWidgetItem(str(id))
        item.setFlags(item.flags() & ~Qt.ItemIsEditable)
        item2 = QTableWidgetItem(str(fecha))
        item2.setFlags(item2.flags() & ~Qt.ItemIsEditable)
        self.dlg.tableWidget.setItem(rowPosition, 0, item)
        self.dlg.tableWidget.setItem(rowPosition, 1, QTableWidgetItem(str(direccion)))
        self.dlg.tableWidget.setItem(rowPosition, 2, QTableWidgetItem(str(applicant)))
        self.dlg.tableWidget.setItem(rowPosition, 3, QTableWidgetItem(str(phone)))
        self.dlg.tableWidget.setItem(rowPosition, 4, QTableWidgetItem(str(operador)))
        self.dlg.tableWidget.setItem(rowPosition, 5, QTableWidgetItem(coordenada_partida))
        self.dlg.tableWidget.setItem(rowPosition, 6, QTableWidgetItem(str(coordenada_lugar)))
        self.dlg.tableWidget.setItem(rowPosition, 7, QTableWidgetItem(description))
        self.dlg.tableWidget.setItem(rowPosition, 8, QTableWidgetItem(str(estimatedTime)))
        self.dlg.tableWidget.setItem(rowPosition, 9, QTableWidgetItem(str(estimatedActual)))
        self.dlg.tableWidget.setItem(rowPosition, 10, QTableWidgetItem(type))
        self.dlg.tableWidget.setItem(rowPosition, 11, QTableWidgetItem(item2))
        updateButton = QPushButton("Modificar")
        updateButton.clicked.connect(lambda: self.updateOrder(id))
        self.dlg.tableWidget.setCellWidget(rowPosition, 12, updateButton)
        

    def changeScreenSeeOrders(self):
        self.dlg = EmergencyDispatcherDialogSeeOrders()
        self.dlg.setFixedSize(self.dlg.size())
        self.dlg.show()
        self.dlg.tableWidget.setColumnCount(13)
        self.dlg.tableWidget.setHorizontalHeaderLabels(["Numero ID", "Direccion", "Solicitante", "Telefono", "Operador", "Coordenada de partida", "Coordenada del lugar", "Descripcion", "Tiempo Estimado", "Tiempo Real", "Tipo", "Fecha", "Modificar"])
        self.loadOrdersTable()
        self.canvas = self.iface.mapCanvas()
        self.clickTool = QgsMapToolEmitPoint(self.canvas)
        self.dlg.back_to.clicked.connect(lambda: self.backScreen())
        self.dlg.aceptar.clicked.connect(lambda: self.backScreen())
        self.dlg.cargar_planilla.clicked.connect(lambda: self.selectOrders())
        self.dlg.cargar.clicked.connect(lambda: self.loadOrders())
        self.dlg.exportar.clicked.connect(lambda: self.exportar_orders_tabla())
    
    def loadOrdersTable(self):
        records = select("orders")
        for tuple in records:
            self.addOrder(tuple[0], tuple[1], tuple[2], tuple[3], tuple[4], tuple[5], tuple[6], tuple[7], tuple[8], tuple[11], tuple[10], tuple[12])

    def exportar_orders_tabla(self):
        try:
            createAndDownloadOds()
            QMessageBox.information(self.dlg, 'exportar_orders_tabla', "Se exportó el archivo en "+PATH_RUTA_EXPORT)
        except Exception as e:
            QgsMessageLog.logMessage(str(e))
            QMessageBox.warning(self.dlg, 'exportar_orders_tabla', "Ocurrio un error al exportar el archivo.")

    def selectOrders(self):
        file_dialog = QFileDialog()
        file_dialog.setNameFilter("Archivos ODS (*.ods)")
        file_dialog.setFileMode(QFileDialog.ExistingFile)
        if file_dialog.exec_():
            file_paths = file_dialog.selectedFiles()
            selected_file_path = file_paths[0]
            self.dlg.cargar_planilla.setText(selected_file_path)
            self.pathLoadTemplate = selected_file_path
            
            
    def loadOrders(self):
        if self.pathLoadTemplate is not None:
            loadOrders(self.pathLoadTemplate)
            self.loadOrdersTable()
            self.pathLoadTemplate = None
            self.dlg.cargar_planilla.setText("Seleccionar archivo")
        else:
            QMessageBox.warning(self.dlg, 'loadOrders', "Seleccione un archio .ods para cargar los orders")



    def loadListPoints(self):
        records = select('points')
        i=1
        if (len(records) > 0) :
            for tuple in records:
                if i % 2 == 0:
                    stopPointExclution = tuple[2]+','+tuple[1]
                    self.listPointsExclution.append((startPointExclution, stopPointExclution, stopPointExclution))
                else:
                    startPointExclution = tuple[2]+','+tuple[1]
                i+=1
        

    def savePointsExclution(self):
        if len(self.dlg.startTxt.text()) > 0 and len(self.dlg.stopTxt.text()) > 0:
            if platform.system() == 'Windows':
                startPointExclution = self.dlg.startTxt.text()
                stopPointExclution = self.dlg.stopTxt.text()
            else:
                pointsStart = self.dlg.startTxt.text().split(',')
                startPointExclution = pointsStart[1]+','+pointsStart[0]
                pointsStop = self.dlg.stopTxt.text().split(',')
                stopPointExclution = pointsStop[1]+','+pointsStop[0]
            
            #Inserta los points en la BD 
            startPoint = startPointExclution.split(',')
            stopPoint = stopPointExclution.split(',')

            insertPoint(startPoint[1], startPoint[0], self.dlg.descriptionTxt.text())
            insertPoint(stopPoint[1], stopPoint[0], self.dlg.descriptionTxt.text())

        self.addUpdateInitialPoints()
        self.dlg = self.dlgBack
        if self.dlg.close():
            self.addUpdateInitialPoints()  
            self.dlg.showNormal()

    def savePoints(self):
        try:
            self.calculatePoints()    
        except Exception as e:
            QgsMessageLog.logMessage(str(e))
            QMessageBox.warning(self.dlg, 'savePoints', "Error al intentar guardar los points")

    def backScreen(self):
        self.dlg = self.dlgBack
        self.dlg.show()
        self.addUpdateInitialPoints()

    def addPointWithcon(self, point, icon_path, nombre_layer = "Custom Marker Layer"):
        vl = QgsVectorLayer("Point?crs=EPSG:4326", nombre_layer, "memory")
        pr = vl.dataProvider()
        vl.startEditing()
        # Crear una característica (feature) en el point inicial
        feat = QgsFeature()
        feat.setGeometry(QgsGeometry.fromPointXY(point))
        pr.addFeatures([feat])
        vl.updateExtents()
        # Crear un símbolo SVG personalizado
        symbol = QgsMarkerSymbol.createSimple({'name': 'circle', 'color': 'black'})
        svg_layer = QgsSvgMarkerSymbolLayer(icon_path)
        svg_layer.setSize(10)
        symbol.changeSymbolLayer(0, svg_layer)
        
        # Aplicar el símbolo personalizado a la layer
        renderer = vl.renderer()
        renderer.setSymbol(symbol)
        QgsProject.instance().addMapLayer(vl)
        self.canvas.setExtent(vl.extent())
        self.canvas.refresh()
        return vl

    def addUpdateInitialPoints(self):
        self.deleteAllPoints()
        self.vectorRubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        self.vectorRubberBand.setColor(QColor("#000000"))
        self.vectorRubberBand.setWidth(4)
        self.startRubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
        self.startRubberBand.setColor(QColor("#000000"))
        self.startRubberBand.setIconSize(10)
        self.startRubberBand.setIcon(QgsRubberBand.ICON_FULL_BOX)
        self.stopRubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
        self.stopRubberBand.setColor(QColor("#000000"))
        self.stopRubberBand.setIconSize(10)
        self.stopRubberBand.setIcon(QgsRubberBand.ICON_FULL_BOX)
        records = select('points')
        points = []
        for i, record in enumerate(records, start=1):
            point = QgsPointXY(float(record[1]), float(record[2]))
            points.append(point)

            if i % 2 == 0:
                self.vectorRubberBand.addGeometry(QgsGeometry.fromPolygonXY([points]), None)
                points = []
                self.stopRubberBand.addPoint(point)
            else:
                self.startRubberBand.addPoint(point)

        records=select('pump')
        for tuple in records:
            layer = self.addPointWithcon(QgsPointXY(float(tuple[1]), float(tuple[2])), PATH_IMAGEN_BOMBAS_ICON_SVG, "Bomba")
            if (layer not in self.layerPumps):
                self.layerPumps.append(layer)

        allLayers = QgsProject.instance().mapLayers().values()
        if self.layerStartPoint not in allLayers:    
            layer = self.addPointWithcon(self.startPointXY, PATH_IMAGEN_CUARTEL_ICON_SVG, "Punto Inicial")
            self.layerStartPoint = layer
            
    def run(self):
        self.no = 0
        startingPoint = STARTING_POINT.split(',')
        self.startPointXY = QgsPointXY(float(startingPoint[0]), float(startingPoint[1]))
        self.stopPointXY = None
        createTablePoint()
        createTablePump()
        createTableOrder()
        self.dlg = EmergencyDispatcherDialog()
        
        self.dlg.setFixedSize(self.dlg.size())

        self.services = RouteProvider().services()

        self.canvas = self.iface.mapCanvas()
        self.clickTool = QgsMapToolEmitPoint(self.canvas)  # clicktool instance generated in here.
        
        self.dlgBack = self.dlg
        self.dlg.btnAgPedido.clicked.connect(lambda: self.changeScreenPlaceAnOrder())
        self.dlg.btnModMapa.clicked.connect(lambda: self.changeScreenModifyMap())
        self.dlg.btnModBombas.clicked.connect(lambda: self.changeScreenModifyPump())
        self.dlg.btn_ver_orders.clicked.connect(lambda: self.changeScreenSeeOrders())
        self.dlg.btnStatistics.clicked.connect(lambda: self.changeScreenStatistics())
        self.vectorRubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        self.vectorRubberBand.setColor(QColor("#000000"))
        self.vectorRubberBand.setWidth(4)
        self.startRubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
        self.startRubberBand.setColor(QColor("#000000"))
        self.startRubberBand.setIconSize(10)
        self.startRubberBand.setIcon(QgsRubberBand.ICON_FULL_BOX)
        self.stopRubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
        self.stopRubberBand.setColor(QColor("#000000"))
        self.stopRubberBand.setIconSize(10)
        self.stopRubberBand.setIcon(QgsRubberBand.ICON_FULL_BOX)
        self.addUpdateInitialPoints()
        self.dlg.show()
        self.dlg.closeEvent = self.close

    def close(self, event):
        #clear the rubberbands
        self.canvas.scene().removeItem(self.startRubberBand)
        self.canvas.scene().removeItem(self.stopRubberBand)
        self.canvas.scene().removeItem(self.vectorRubberBand)
        self.deleteLayerPumps()
        allLayers = QgsProject.instance().mapLayers().values()
        if self.layerStartPoint in allLayers:
            QgsProject.instance().removeMapLayer(self.layerStartPoint)
            self.layerStartPoint = None

        
    def closeOrder(self, event):
        layerOrder = QgsProject.instance().mapLayersByName("Pedidos")
        if layerOrder:
            for layer in layerOrder:
                with edit(layer):
                    layer.dataProvider().deleteFeatures([f.id() for f in layer.getFeatures()])
                QgsProject.instance().removeMapLayer(layer.id())
        self.addUpdateInitialPoints()
        self.canvas.unsetMapTool(self.clickTool)

    def closeUpdate(self, event):
        self.dlgBack.closeEvent = self.close
        self.addUpdateInitialPoints()